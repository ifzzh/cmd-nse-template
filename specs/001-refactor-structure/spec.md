# 特性规范：项目结构重构 - 降低耦合度提升可维护性

**特性分支**: `001-refactor-structure`
**创建日期**: 2025-11-11
**状态**: 草案
**原始需求**: "项目结构调整。本项目是一个NSM中的一个基于VPP的防火墙，但其项目耦合程度太高，理解起来有点难度，我希望在现有基础上拆解一下，但最小化改动和开发，严格保持原有的逻辑"

## 用户场景与测试 *(强制)*

### 用户场景1 - 将配置管理独立为模块 (优先级: P1)

作为项目开发者或维护者，我希望能够快速理解和修改配置相关的代码，而不需要在380行的main.go中搜索配置逻辑。

**优先级理由**: 配置是应用程序的基础，独立的配置模块可以立即提升代码可读性，并为后续重构打下基础。这是最基础且风险最低的重构步骤。

**独立测试**: 可以通过验证配置加载、环境变量解析、ACL规则读取功能是否正常工作来独立测试。验证方式：提供不同的环境变量和配置文件，确认配置对象正确初始化。

**验收场景**:

1. **给定** 环境变量NSM_NAME=test-firewall，**当** 应用启动时，**那么** 配置模块正确解析并返回Name="test-firewall"
2. **给定** ACL配置文件存在于/etc/firewall/config.yaml，**当** 调用配置加载方法时，**那么** ACL规则被正确解析并存储
3. **给定** 日志级别设置为DEBUG，**当** 配置初始化时，**那么** 日志系统使用DEBUG级别
4. **给定** 配置文件不存在，**当** 尝试加载ACL规则时，**那么** 记录错误日志但不中断应用启动

---

### 用户场景2 - 将VPP连接管理提取为独立层 (优先级: P2)

作为开发者，我希望VPP连接的建立、错误处理和生命周期管理被封装在独立模块中，这样在排查VPP相关问题时可以快速定位代码位置。

**优先级理由**: VPP连接是核心功能，但当前与main函数耦合。独立后可以提高测试性和可维护性，特别是在VPP连接故障时便于排查。

**独立测试**: 可以通过模拟VPP连接场景（成功连接、连接失败、连接中断）来独立测试。验证方式：使用测试环境启动VPP实例，验证连接模块能否正确处理各种连接状态。

**验收场景**:

1. **给定** VPP服务正在运行，**当** 初始化VPP连接管理器时，**那么** 成功建立连接并返回有效的连接对象
2. **给定** VPP服务未运行，**当** 尝试建立连接时，**那么** 返回明确的错误信息并通过错误通道传递
3. **给定** VPP连接已建立，**当** VPP服务意外终止时，**那么** 错误通道接收到连接断开事件
4. **给定** 应用正在关闭，**当** 调用清理方法时，**那么** VPP连接被正确关闭

---

### 用户场景3 - 将gRPC服务器配置和启动逻辑模块化 (优先级: P3)

作为开发者，我希望gRPC服务器的创建、TLS配置、注册逻辑被组织在清晰的结构中，便于理解服务端点的生命周期管理。

**优先级理由**: gRPC服务器是应用的对外接口，但当前配置分散。模块化后可以更容易地修改服务器配置、添加新的gRPC服务，或者排查连接问题。

**独立测试**: 可以通过启动服务器、验证TLS配置、测试服务注册来独立测试。验证方式：使用gRPC客户端连接服务器，验证TLS握手和服务调用是否正常。

**验收场景**:

1. **给定** SPIFFE证书已就绪，**当** 初始化gRPC服务器时，**那么** TLS配置正确应用
2. **给定** 服务器已启动，**当** 客户端尝试连接时，**那么** 连接成功并能调用服务方法
3. **给定** 服务器监听路径为unix socket，**当** 启动服务器时，**那么** socket文件在临时目录中创建
4. **给定** 应用正在关闭，**当** 调用服务器停止方法时，**那么** 优雅关闭并清理临时文件

---

### 用户场景4 - 将NSM端点创建逻辑封装为工厂模式 (优先级: P4)

作为开发者，我希望NSM防火墙端点的创建逻辑（包括ACL、xconnect、memif等组件的组装）被封装在专门的构建器或工厂中，而不是在main函数中直接组装60+行的chain。

**优先级理由**: 端点创建逻辑是业务核心，但当前与其他初始化逻辑混在一起。封装后可以更清晰地理解端点的组成，便于添加或移除功能组件。

**独立测试**: 可以通过提供不同的配置参数来测试端点创建。验证方式：使用测试配置创建端点，验证所有组件是否正确初始化并按预期顺序组装。

**验收场景**:

1. **给定** 完整的配置和VPP连接，**当** 调用端点工厂方法时，**那么** 返回包含所有必需组件的端点实例
2. **给定** 配置中指定了ACL规则，**当** 创建端点时，**那么** ACL组件被正确配置并包含在chain中
3. **给定** 端点已创建，**当** 注册到gRPC服务器时，**那么** NetworkService服务可被远程调用
4. **给定** 缺少必需的依赖（如VPP连接），**当** 尝试创建端点时，**那么** 返回明确的错误信息

---

### 用户场景5 - 将NSM注册逻辑提取为服务模块 (优先级: P5)

作为开发者，我希望NSM Registry的连接、端点注册、策略配置等逻辑被组织在独立的注册服务中，便于理解和修改注册流程。

**优先级理由**: 注册逻辑是应用启动的最后一步，独立后可以更容易地排查注册失败问题，或者修改注册策略。

**独立测试**: 可以通过连接测试环境的NSM Registry来测试。验证方式：启动注册服务，验证端点是否成功注册到Registry并可被发现。

**验收场景**:

1. **给定** NSM Manager可访问，**当** 调用注册服务时，**那么** 端点成功注册并返回注册信息
2. **给定** 注册策略文件存在，**当** 初始化注册客户端时，**那么** 策略被正确加载并应用
3. **给定** 网络断开，**当** 尝试注册时，**那么** 返回连接错误并允许重试
4. **给定** 应用正在关闭，**当** 调用注销方法时，**那么** 端点从Registry中移除

---

### 边界情况

- **配置文件缺失**: ACL配置文件不存在时，系统能否以默认规则启动？（当前实现：记录错误但继续运行）
- **VPP连接断开**: 运行时VPP服务崩溃，系统如何处理？（当前实现：通过错误通道取消context）
- **并发场景**: 多个goroutine同时访问VPP连接时的同步问题
- **资源清理**: 在各种异常退出场景下（SIGTERM、panic等），临时文件和socket是否正确清理？
- **重构后的模块边界**: 重构后各模块间的依赖关系是否清晰，避免循环依赖？

## 需求 *(强制)*

### 功能性需求

- **FR-001**: 系统必须将配置管理逻辑（包括环境变量解析、ACL规则加载）提取到独立的config包中
- **FR-002**: 系统必须创建独立的vpp包，封装VPP连接的建立、错误处理和生命周期管理
- **FR-003**: 系统必须创建server包，封装gRPC服务器的创建、TLS配置、启动和停止逻辑
- **FR-004**: 系统必须创建endpoint包，提供防火墙端点的构建器或工厂，封装复杂的chain组装逻辑
- **FR-005**: 系统必须创建registry包，封装NSM端点注册、注销和策略管理逻辑
- **FR-006**: 重构后的main.go必须只负责高层次的应用生命周期管理（初始化、启动、停止），业务逻辑委托给各模块
- **FR-007**: 重构必须保持现有的所有功能不变，包括配置方式、ACL规则格式、gRPC接口等
- **FR-008**: 每个新模块必须有清晰的职责边界，避免模块间的紧耦合
- **FR-009**: 重构必须保持与现有NSM SDK和VPP SDK的兼容性
- **FR-010**: 所有新增模块必须添加中文注释，说明模块用途和关键方法

### 关键实体

- **配置对象（Config）**: 代表应用的全部配置，包括服务名称、连接URL、ACL规则、日志级别等
- **VPP连接管理器（VPPManager）**: 管理与VPP的连接生命周期，提供连接获取和错误监控接口
- **gRPC服务器包装器（ServerWrapper）**: 封装gRPC服务器的创建和生命周期，包括TLS配置和socket管理
- **端点构建器（EndpointBuilder）**: 负责组装防火墙端点的所有组件（ACL、xconnect、memif等）
- **注册服务（RegistryService）**: 管理与NSM Registry的交互，包括注册、注销和策略应用

## 成功标准 *(强制)*

### 可衡量的结果

- **SC-001**: 重构后main.go的代码行数减少到100行以内（当前380行），主要用于模块协调和生命周期管理
- **SC-002**: 每个新模块（config、vpp、server、endpoint、registry）的职责单一明确，可以独立理解和测试
- **SC-003**: 重构后通过所有现有测试（如果存在），确保功能完全保持不变
- **SC-004**: 新代码的注释覆盖率达到80%以上，所有公开函数和类型必须有中文文档注释
- **SC-005**: 重构后的代码无循环依赖，依赖关系清晰（通过Go module graph验证）
- **SC-006**: 构建时间不增加超过10%（确保重构不引入性能问题）
- **SC-007**: 原有的6个启动阶段逻辑保持不变，但实现被委托到各模块
- **SC-008**: 开发者能够在5分钟内理解任一模块的职责和核心逻辑（通过代码审查验证）

## 假设

### 技术假设

- **ASM-001**: 项目将继续使用当前的NSM SDK和VPP SDK版本，不进行大版本升级
- **ASM-002**: 重构不涉及外部API或配置格式的变更，对用户透明
- **ASM-003**: 所有新模块将放置在internal目录下，遵循Go项目标准布局
- **ASM-004**: 重构采用渐进式方法，每个模块的提取可以分别进行和测试

### 业务假设

- **ASM-005**: 当前代码已在生产环境验证，功能正确性不需要重新验证（只需确保重构后功能不变）
- **ASM-006**: 项目目标用户是熟悉NSM和VPP的开发者，重构后的代码应便于此类用户理解
- **ASM-007**: 未来可能需要添加更多网络功能（如负载均衡、流量镜像），模块化结构应便于扩展

## 依赖

### 外部依赖

- **DEP-001**: 依赖NSM SDK提供的endpoint、client、registry等核心API
- **DEP-002**: 依赖NSM VPP SDK提供的acl、memif、xconnect等VPP集成组件
- **DEP-003**: 依赖VPPHelper进行VPP进程管理和连接建立
- **DEP-004**: 依赖SPIFFE/SPIRE提供的身份认证和TLS配置

### 内部依赖

- **DEP-005**: 新模块之间的依赖应保持单向：main → registry/server/endpoint → vpp/config
- **DEP-006**: 避免config模块依赖业务逻辑模块，保持配置的纯粹性

## 范围界定

### 包含在内

- 将main.go中的配置、VPP、服务器、端点、注册逻辑分离到独立模块
- 为每个模块添加清晰的中文文档注释
- 保持所有现有功能和行为不变
- 简化main.go的结构，使其成为纯粹的协调层

### 明确排除

- 不修改ACL规则的配置格式或加载方式
- 不修改gRPC接口定义或网络协议
- 不升级NSM SDK或VPP SDK的版本
- 不添加新的业务功能（如新的网络服务类型）
- 不修改构建流程或Docker镜像结构
- 不重写测试框架或添加单元测试（如果不存在）

## 约束

### 技术约束

- **CON-001**: 必须保持Go 1.23.8兼容性
- **CON-002**: 必须遵守项目宪章的"功能完整性原则"，严禁破坏现有功能
- **CON-003**: 必须遵守项目宪章的"一致性优先原则"，新代码风格与现有代码保持一致
- **CON-004**: 重构必须最小化改动范围，避免引入不必要的复杂度
- **CON-005**: 所有新增代码必须使用中文注释（符合"中文优先原则"）

### 组织约束

- **CON-006**: 重构必须在不影响项目正常迭代的前提下进行
- **CON-007**: 每个模块的提取应作为独立的可测试单元，支持增量合并
- **CON-008**: 重构前需要完成充分的代码审查，确认方案可行

## 风险

### 技术风险

- **RISK-001**: 重构可能引入难以发现的细微行为变化（缓解措施：保持细粒度提交，逐模块验证）
- **RISK-002**: 模块边界划分不当可能导致新的耦合问题（缓解措施：遵循单一职责原则，代码审查）
- **RISK-003**: 依赖注入或初始化顺序变更可能导致运行时错误（缓解措施：保持现有初始化流程）

### 项目风险

- **RISK-004**: 重构周期过长可能阻塞其他特性开发（缓解措施：采用渐进式重构，每个模块独立完成）
- **RISK-005**: 团队成员对新结构不熟悉可能降低短期开发效率（缓解措施：完善文档和代码注释）

## 后续步骤

1. 使用 `/speckit.clarify` 命令识别规范中需要进一步明确的问题（如果有）
2. 使用 `/speckit.plan` 命令创建详细的实施计划，包括模块划分和重构步骤
3. 使用 `/speckit.tasks` 命令生成具体的开发任务清单
