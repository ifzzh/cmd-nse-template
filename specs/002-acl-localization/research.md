# Research & Decisions: ACL 模块本地化

**Feature**: 002-acl-localization | **Date**: 2025-11-13 (更新) | **Phase**: 0 (研究与决策)

## 研究目标

解决 govpp ACL binapi 模块本地化过程中的所有技术未知项，确定具体的工作流程和工具链。

**关键澄清更新**: 根据 2025-11-13 的澄清，binapi 模块将与 `internal/acl/` 并列放置，不使用 `local-deps/` 子目录。

## 关键决策

### 决策 1: Go 模块源码获取方法

**问题**: 如何根据 go.sum 中的精确版本哈希下载对应版本的 govpp binapi 模块源码？

**选项评估**:

| 选项 | 优势 | 劣势 | 评分 |
|------|------|------|------|
| A. 使用 `go mod download` | 官方工具，自动处理依赖 | 下载整个模块到缓存，不易定位 | 7/10 |
| B. 直接 git clone 对应 commit | 版本精确，可验证哈希 | 需要手动计算 commit hash | 8/10 |
| C. 使用 `go mod vendor` | 自动提取到 vendor/ | 包含所有依赖，体积大 | 6/10 |
| D. 组合方案: go mod download + 从缓存复制 | 精确且可验证 | 需要找到缓存位置 | **9/10** |

**最终决策**: **选项 D - 组合方案**

**理由**:
1. `go mod download` 确保下载的代码与 go.sum 精确匹配
2. Go 模块缓存位置固定: `$GOPATH/pkg/mod/github.com/networkservicemesh/govpp@v0.0.0-20240328101142-8a444680fbba/`
3. 从缓存复制 `binapi/acl` 和 `binapi/acl_types` 目录到 `internal/` (并列放置)
4. 可验证哈希一致性，确保版本严格对应

**实施步骤**（已更新目录结构）:
```bash
# 步骤 1: 确保模块已下载到缓存
go mod download github.com/networkservicemesh/govpp

# 步骤 2: 定位缓存目录
GOVPP_CACHE=$(go env GOPATH)/pkg/mod/github.com/networkservicemesh/govpp@v0.0.0-20240328101142-8a444680fbba

# 步骤 3: 复制 binapi/acl_types 到本地 (与 acl/ 并列)
mkdir -p internal/acl_types
cp -r $GOVPP_CACHE/binapi/acl_types/* internal/acl_types/

# 步骤 4: 复制 binapi/acl 到本地 (命名为 binapi_acl 避免冲突)
mkdir -p internal/binapi_acl
cp -r $GOVPP_CACHE/binapi/acl/* internal/binapi_acl/

# 步骤 5: 取消只读权限（缓存文件默认只读）
chmod -R u+w internal/acl_types/
chmod -R u+w internal/binapi_acl/
```

**命名说明**:
- `internal/acl_types/` 对应 govpp binapi/acl_types（与上游名称一致）
- `internal/binapi_acl/` 对应 govpp binapi/acl（加 binapi 前缀避免与现有 `internal/acl/` 冲突）

**风险与缓解**:
- **风险**: 缓存目录文件只读，无法直接编辑
- **缓解**: 复制后使用 `chmod u+w` 取消只读

---

### 决策 2: go.mod replace 指令配置

**问题**: 如何正确配置 go.mod replace 指令，使项目引用本地化后的 govpp binapi 模块？

**技术调研**:

Go modules replace 指令支持两种路径格式：
1. **相对路径**: `replace github.com/foo/bar => ./local/path`
2. **绝对路径**: `replace github.com/foo/bar => /absolute/path`

由于 binapi 模块是子包（subpackage），需要特殊处理。

**最终决策**: **使用相对路径 + 子包映射**（已更新目录路径）

**理由**:
1. 相对路径确保项目可移植（不依赖绝对路径）
2. 子包必须独立 replace，不能用父包替换（Go modules 限制）
3. 保持 go.mod 简洁，仅替换实际使用的模块
4. 与 internal/acl 并列放置，结构清晰

**实施配置**（已更新）:
```go
// 在 go.mod 文件末尾添加 replace 指令
replace (
    github.com/networkservicemesh/govpp/binapi/acl_types => ./internal/acl_types
    github.com/networkservicemesh/govpp/binapi/acl => ./internal/binapi_acl
)
```

**验证方法**:
```bash
# 验证 replace 生效
go list -m github.com/networkservicemesh/govpp/binapi/acl
# 期望输出: github.com/networkservicemesh/govpp/binapi/acl => ./internal/binapi_acl

go list -m github.com/networkservicemesh/govpp/binapi/acl_types
# 期望输出: github.com/networkservicemesh/govpp/binapi/acl_types => ./internal/acl_types

# 编译测试
go build ./...
```

**注意事项**:
- 本地模块目录必须包含 `go.mod` 文件（即使是虚拟的）
- 如果 binapi 子包没有独立 go.mod，需要手动创建最小化版本

---

### 决策 3: VPP binapi 代码结构理解

**问题**: govpp binapi 模块是如何生成的？包含哪些文件？是否可以安全修改？

**调研发现**:

govpp binapi 代码由 `binapi-generator` 工具从 VPP API JSON 文件自动生成，包含：

1. **`<api>.ba.go`**: 核心 API 绑定代码
   - 数据结构定义（对应 VPP API 结构体）
   - 消息类型定义（实现 `api.Message` 接口）
   - 序列化/反序列化方法

2. **`<api>_rpc.ba.go`**: RPC 客户端代码
   - RPC 服务接口定义
   - 异步调用方法
   - 流式 API 方法

3. **生成特征**:
   - 文件头部有自动生成标记: `// Code generated by GoVPP's binapi-generator. DO NOT EDIT.`
   - 包名固定为模块名（如 `package acl`）
   - 依赖 `go.fd.io/govpp/api` 和其他 binapi 模块

**针对 binapi/acl 模块**:
```
binapi/acl/  (本地化后: internal/binapi_acl/)
├── acl.ba.go           # ACL API 绑定（约 1200 行）
└── acl_rpc.ba.go       # ACL RPC 客户端（约 200 行）
```

**针对 binapi/acl_types 模块**:
```
binapi/acl_types/  (本地化后: internal/acl_types/)
└── acl_types.ba.go     # ACL 类型定义（约 300 行）
```

**最终决策**: **最小化修改策略**

**允许的修改**:
1. ✅ 包级别文档注释（添加中文说明）
2. ✅ 导入路径调整（如需引用其他本地化模块）
3. ✅ 错误信息中文化（如有字符串字面量）

**禁止的修改**:
1. ❌ 数据结构定义（会破坏 VPP API 兼容性）
2. ❌ 接口签名（会破坏调用者代码）
3. ❌ 序列化逻辑（会导致通信失败）
4. ❌ RPC 方法定义（会破坏协议）

**实施原则**:
- 保持代码 99% 不变，仅添加包级别中文注释
- 不修改任何函数、方法、类型的定义
- 如有日志输出，可中文化（实际上 binapi 代码无日志）

---

### 决策 4: 日志中文化策略

**问题**: govpp binapi 模块中有多少日志需要中文化？如何实施？

**调研结果**:

经检查 govpp binapi 代码特征，发现：
- **binapi 自动生成代码不包含日志输出**
- 代码仅包含数据结构、接口定义和序列化逻辑
- 无 `log.*` 或 `fmt.Printf` 等输出语句

**最终决策**: **无需日志中文化**

**理由**:
1. binapi 代码是纯数据层，不包含业务逻辑和日志
2. 日志由调用方（如 `internal/acl/`）负责，已在 sdk-vpp ACL 本地化时处理
3. 过度修改自动生成代码会增加维护风险

**替代方案**:
- 在每个本地化模块目录下添加 `README.md`，用中文说明模块用途和来源
- 在包级别添加中文文档注释（可选）

**示例**（针对 internal/acl_types/）:
```go
// Package acl_types 提供 VPP ACL 类型定义的 Go 语言绑定。
//
// 本模块由 GoVPP binapi-generator 自动生成，对应 VPP API 版本。
// 原始仓库: github.com/networkservicemesh/govpp@v0.0.0-20240328101142-8a444680fbba
// 本地化日期: 2025-11-13
//
// 注意: 本代码为自动生成，请勿手动修改数据结构和接口定义。
package acl_types
```

---

### 决策 5: Docker 镜像版本自动递增机制

**问题**: 如何实现镜像版本号从 v1.0.0 自动递增到 v1.0.1, v1.0.2？

**选项评估**:

| 选项 | 实现方式 | 优势 | 劣势 | 评分 |
|------|---------|------|------|------|
| A. 手动修改 Dockerfile 标签 | 每次手动编辑 `docker build -t ...` | 简单直接 | 易出错，无自动化 | 4/10 |
| B. Git tag 驱动 | 基于 git tag 生成版本 | 版本控制集成 | 需要额外脚本 | 7/10 |
| C. 读取 VERSION 文件 | 维护单独版本文件 | 集中管理 | 需要手动更新 | 6/10 |
| D. Makefile 自动递增 | Makefile 读取并递增补丁版本 | 半自动化 | 需要 Makefile | **8/10** |

**最终决策**: **选项 C - VERSION 文件 + 手动递增**（更符合"由用户测试"的要求）

**理由**:
1. 符合用户要求"通过 git 和 docker 打包来迭代控制"
2. 简单可控，避免过度自动化导致意外推送
3. 每次本地化由用户确认版本号后构建镜像

**实施方案**:

创建 `VERSION` 文件记录当前版本，每次本地化手动递增：

```bash
# 每次本地化后手动递增版本
echo "v1.0.1" > VERSION

# 构建镜像
VERSION=$(cat VERSION)
docker build -t ifzzh520/vpp-acl-firewall:${VERSION} .
docker push ifzzh520/vpp-acl-firewall:${VERSION}

# Git 提交包含 VERSION 文件
git add VERSION internal/acl_types/ (或 internal/binapi_acl/)
git commit -m "feat: 本地化模块 X，版本 ${VERSION}"
git tag ${VERSION}
git push origin ${VERSION}
```

**VERSION 文件示例**:
```
v1.0.2
```

**可选增强（脚本辅助）**:

创建 `scripts/build-image.sh` 脚本简化流程：
```bash
#!/bin/bash
set -e

VERSION=$(cat VERSION)
IMAGE_NAME="ifzzh520/vpp-acl-firewall"

echo "当前版本: ${VERSION}"
echo "构建镜像: ${IMAGE_NAME}:${VERSION}"

# 构建镜像
docker build -t ${IMAGE_NAME}:${VERSION} -t ${IMAGE_NAME}:latest .

echo "✅ 镜像构建完成"
echo "推送镜像? (y/n)"
read -r PUSH_CONFIRM
if [ "$PUSH_CONFIRM" = "y" ]; then
    docker push ${IMAGE_NAME}:${VERSION}
    docker push ${IMAGE_NAME}:latest
    echo "✅ 镜像已推送: ${IMAGE_NAME}:${VERSION}"
fi
```

**使用流程**:
1. 本地化一个模块
2. 手动编辑 VERSION 文件递增版本号（v1.0.1 → v1.0.2）
3. Git 提交
4. 运行 `./scripts/build-image.sh` 构建镜像
5. 推送镜像供用户测试
6. Git tag 打标签

---

### 决策 6: 本地模块 go.mod 依赖处理

**问题**: 本地化后的 binapi 模块是否需要独立的 go.mod 文件？

**技术调研**:

Go modules replace 机制有两种模式：
1. **模块级别 replace**: 替换整个模块（需要目标有 go.mod）
2. **包级别 replace**: 替换子包（不强制要求 go.mod，但建议有）

**实际情况**:
- govpp binapi 子包（如 `binapi/acl`）在原仓库中**没有独立的 go.mod**
- 它们依赖父模块 `github.com/networkservicemesh/govpp` 的 go.mod
- 本地化后需要模拟这种依赖关系

**最终决策**: **创建最小化 go.mod**（已更新模块路径）

**理由**:
1. 明确声明模块依赖，便于 `go build` 解析
2. 避免 Go modules 警告和错误
3. 保持项目结构清晰

**实施方案**:

为每个本地化模块创建 `go.mod`:

```go
// internal/acl_types/go.mod
module github.com/ifzzh/cmd-nse-template/internal/acl_types

go 1.23

require (
    go.fd.io/govpp v0.11.0
)
```

```go
// internal/binapi_acl/go.mod
module github.com/ifzzh/cmd-nse-template/internal/binapi_acl

go 1.23

require (
    go.fd.io/govpp v0.11.0
    github.com/networkservicemesh/govpp/binapi/acl_types v0.0.0-20240328101142-8a444680fbba
)
```

**依赖处理策略**:
- ✅ 保留 `go.fd.io/govpp` 在线依赖（VPP 基础库，不本地化）
- ✅ 如果 `binapi/acl` 依赖 `binapi/acl_types`，在 go.mod 中声明
- ❌ 不本地化非 ACL 的其他 binapi 模块

**验证**:
```bash
cd internal/acl_types
go mod tidy  # 自动补全依赖
go build .   # 验证可编译

cd ../binapi_acl
go mod tidy
go build .
```

---

### 决策 7: 测试验证策略

**问题**: 如何验证本地化后的模块功能正确且无破坏性变更？

**验证层级**:

| 层级 | 验证内容 | 方法 | 责任方 |
|------|---------|------|--------|
| 1. 编译验证 | 代码语法正确，依赖可解析 | `go build ./...` | AI 自动执行 |
| 2. 单元测试 | binapi 模块自带测试通过 | `go test ./internal/acl_types/ ./internal/binapi_acl/` | AI 自动执行 |
| 3. 集成测试 | Docker 构建成功 | `docker build --target test .` | AI 自动执行 |
| 4. 功能测试 | 完整防火墙功能可用 | 部署到测试环境 | **用户执行** |

**最终决策**: **分层验证 + 用户最终确认**

**AI 自动执行验证**:
```bash
# 步骤 1: 编译验证
go build ./...
echo "✅ 编译通过"

# 步骤 2: 运行单元测试（如果存在）
go test ./internal/acl_types/ ./internal/binapi_acl/ || echo "⚠️  无单元测试或测试失败"

# 步骤 3: Docker 多阶段构建测试
docker build --target test -t test-image .
echo "✅ Docker 测试阶段通过"

# 步骤 4: 构建最终镜像
VERSION=$(cat VERSION)
docker build -t ifzzh520/vpp-acl-firewall:${VERSION} .
echo "✅ 镜像构建完成: ifzzh520/vpp-acl-firewall:${VERSION}"

# 步骤 5: 推送镜像（等待用户确认）
echo "请用户测试镜像后确认是否推送"
```

**用户功能测试清单**:
1. 部署新镜像到测试 Kubernetes 集群
2. 验证 NSM 注册成功
3. 验证 VPP 连接正常
4. 验证 ACL 规则加载和应用
5. 验证网络流量过滤功能
6. 检查日志输出无错误

**回滚机制**:
- 如果测试失败，使用上一个稳定镜像版本
- 回滚 git commit: `git reset --hard HEAD~1`
- 删除失败的 git tag: `git tag -d v1.0.X && git push origin :refs/tags/v1.0.X`

---

## 技术风险评估

| 风险 | 影响 | 概率 | 缓解措施 | 优先级 |
|------|------|------|---------|--------|
| go.mod replace 配置错误导致编译失败 | 高 | 中 | 提前验证 replace 语法，使用 `go list -m` 检查 | 高 |
| 缓存文件只读权限导致无法修改 | 中 | 高 | 复制后立即执行 `chmod u+w` | 中 |
| binapi 依赖其他 binapi 模块未本地化 | 中 | 低 | 保持非 ACL 模块在线依赖 | 低 |
| Docker 镜像构建失败 | 高 | 低 | 本地预先测试构建，确保 Dockerfile 无误 | 高 |
| 用户测试失败但无法定位问题 | 中 | 中 | 提供详细日志和回滚指南 | 中 |
| 版本号递增逻辑错误 | 低 | 低 | 使用简单的手动递增 + VERSION 文件 | 低 |
| 目录命名冲突（binapi/acl vs internal/acl） | 中 | 中 | 使用 binapi_acl 命名避免冲突 | 中 |

---

## 工具链和依赖

### 必需工具
- Go 1.23.8+（与项目版本一致）
- Docker（构建和测试）
- Git（版本控制）
- 文本编辑器（修改 go.mod 和添加注释）

### 可选工具
- `golangci-lint`（代码质量检查）
- `go mod graph`（依赖关系可视化）
- `kubectl`（用户部署测试）

---

## 实施顺序建议

根据以上研究和决策，建议的实施顺序：

### 迭代 1: 本地化 binapi/acl_types（依赖较少，风险低）
1. 下载并复制模块源码到 `internal/acl_types/`
2. 创建 go.mod 文件
3. 添加包级别中文注释
4. 创建 README.md 说明模块来源
5. 修改项目 go.mod，添加 replace 指令
6. 本地编译验证
7. Git 提交
8. 构建 Docker 镜像 v1.0.1
9. 推送镜像供用户测试

### 迭代 2: 本地化 binapi/acl（依赖 acl_types，需确保迭代1成功）
1. 确认迭代 1 用户测试通过
2. 下载并复制模块源码到 `internal/binapi_acl/`
3. 创建 go.mod 文件（声明依赖 acl_types）
4. 添加包级别中文注释
5. 创建 README.md 说明模块来源
6. 修改项目 go.mod，添加 replace 指令
7. 本地编译验证
8. Git 提交
9. 构建 Docker 镜像 v1.0.2
10. 推送镜像供用户测试

---

## 后续 Phase 1 准备

Phase 0 研究已完成，所有技术未知项已解决。下一步：

1. **Phase 1**: 更新 quickstart.md（快速开始指南），提供详细的操作步骤（基于新目录结构）
2. **Phase 1**: 更新 data-model.md（数据模型，反映新目录结构）
3. **Phase 1**: 不需要创建 contracts/（本功能无 API 契约）
4. **Phase 1**: 更新 Claude Code agent 上下文（运行 `.specify/scripts/bash/update-agent-context.sh claude`）

---

**研究完成日期**: 2025-11-13 (更新)
**审核状态**: ✅ 所有技术未知项已解决，目录结构已根据澄清更新，可进入 Phase 1
